* lexical-binding
#+name: lexical-binding
#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

* org-contact
#+begin_src emacs-lisp
  (require 'org-contacts)
  (setq org-contacts-files '("~/org/contacts.org"))
#+end_src
* Some bindings for tags
#+name: bindings
#+begin_src emacs-lisp
  (setq notmuch-archive-tags (list "-inbox" "-again"))

  (eval-after-load 'notmuch-show
    '(define-key notmuch-show-mode-map "'" 'notmuch-show-apply-tag-macro))

  (define-key notmuch-search-mode-map "'" 'notmuch-search-apply-tag-macro)

  (defun my-notmuch-tag-delayed ()
    (let ((date (org-read-date)))
      (unless (string-match "^\\(....\\-..\\-..\\) ?\\(..:..\\)?" date)
        (error "internal error: org-mode-read-date"))
      (setq time (match-string 2 date))
      (setq date (match-string 1 date))
      (list (if time
                (format "+w%s-%s" date (replace-regexp-in-string ":" "-" time))
              (format "+w%s" date))
            "+waiting" "-inbox" "-again")))

  (setq notmuch-tag-macro-alist
    (list
     '("t" "+trash" "-inbox")
     '("r" "-unread")
     '("s" "+spam" "-unread" "-inbox")
     '("f" "+flagged")
     '("w" my-notmuch-tag-delayed)
     (list* "a" notmuch-archive-tags)))

  (defun notmuch-show-apply-tag-macro (key)
    (interactive "ktag key: ")
    (let ((tag (my-notmuch-get-tag-macro key)))
      (apply 'notmuch-show-tag-message tag)))

  (defun notmuch-search-apply-tag-macro (key)
    (interactive "ktag key: ")
    (let ((tag (my-notmuch-get-tag-macro key)))
      (if mark-active
          (notmuch-search-tag tag (region-beginning) (region-end))
        (notmuch-search-tag tag))))

  (defun my-notmuch-get-tag-macro (key)
    (let ((macro (assoc key notmuch-tag-macro-alist)))
      (unless macro
        (user-error "unknown key"))
      (when macro
        (let ((tag (cdr macro)))
          (if (functionp (car tag))
              (setq tag (apply (car tag) (cdr tag))))
          tag))))
#+end_src
* muchsync!
#+name: update
#+begin_src emacs-lisp
  (defvar muchsync-default-server ""
    "default server to sync with")

  (defvar muchsync-process)
  (defvar muchsync--idle-timer ()
    "Internal variable: The idle timer for muchsync

  nil if there is no timer")

  (defvar muchsync--idle-timer-again ())

  (defvar muchsync-idle-delay ()
    "Delay to wait when idle to sync

  if nil, do not automaticaly sync
  if not nil, the number of second when idle to lauch a new sync.")

  (define-minor-mode muchsync--modeline-mode
      "Notify mode-line that muchsync is running."
    :global t
    :lighter " [muchsync]")

  (defun muchsync (&optional server hide no-error)
    "run mychsync

  if SERVER is not nil, use that as the server
  otherwise use the value of `muchsync-default-server'"
    (interactive)
    (if (and (boundp 'muchsync-process)
             (process-live-p muchsync-process))
        (unless no-error
          (user-error "muchsync is already running"))
      (let ((buf (get-buffer-create "*muchsync*")))
        (with-current-buffer buf
          (let ((inhibit-read-only t))
            (erase-buffer)
            (unless hide
              (display-buffer buf))
            (setq buffer-read-only t)
            (let ((proc (start-process "*muchsync*" "*muchsync*"
                                       "muchsync" (or server muchsync-default-server) "--nonew")))
              (setq muchsync-process proc)
              (muchsync--modeline-mode 1)
              (set-process-filter proc 'comint-output-filter)
              (require 'shell) (shell-mode)
              (view-mode)
              (setq view-exit-action #'bury-buffer)

              ;; If *notmuch-hello* exists, refresh it after getting the mails
              (set-process-sentinel proc
                                    (lambda (process change)
                                      (when (get-buffer "*notmuch-hello*")
                                        (save-window-excursion
                                          (with-current-buffer "*notmuch-hello*"
                                            (notmuch-refresh-this-buffer))))
                                      (muchsync--modeline-mode -1)
                                      (unless hide
                                        (let ((visible-bell t)) (ding)))))))))))

  (defun muchsync--idle-process ()
    ;; disable any
    (when muchsync--idle-timer-again
      (cancel-timer muchsync--idle-timer-again)
      (setq muchsync--idle-timer-again ()))
    (muchsync () t t)
    (setq muchsync--idle-timer-again
          (run-with-idle-timer (time-add (current-idle-time) (seconds-to-time muchsync-idle-delay))
                               nil
                               #'muchsync--idle-process)))

  (defun muchsync-run-when-idle ()
    (interactive)
    (when (and muchsync-idle-delay
               (or (null muchsync--idle-timer)
                   (not (timerp muchsync--idle-timer))))
      (setq muchsync--idle-timer (run-with-idle-timer muchsync-idle-delay 't 'muchsync--idle-process))))
#+end_src
* Other bindings
#+name: bindings
#+begin_src emacs-lisp
  (setq muchsync-idle-delay 60)

  (setq muchsync-default-server "suvrin.lot-of-stuff.info")

  (define-key notmuch-search-mode-map "g"
    'notmuch-poll-and-refresh-this-buffer)
  (define-key notmuch-hello-mode-map "g"
    'notmuch-poll-and-refresh-this-buffer)

  (define-key notmuch-search-mode-map "G"
    'muchsync)
  (define-key notmuch-hello-mode-map "G"
    'muchsync)

  (defun my-notmuch-browse-or-show ()
    (interactive)
    (if (or
         (thing-at-point 'url t)
         (and (thing-at-point 'filename t)
              (string-match-p "^[^/]*[[:alpha:]]\\{2,4\\}\\(/.*\\)$"
                              (thing-at-point 'filename t))))
        (call-interactively #'browse-url-at-point)
      (notmuch-show-toggle-message)))

  (define-key notmuch-show-mode-map (kbd "RET") 'my-notmuch-browse-or-show)
#+end_src

* Other config
#+name: prompt
#+begin_src emacs-lisp
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-search-oldest-first ())
#+end_src
