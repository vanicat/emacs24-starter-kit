* Configurations de org-mode
** Be sure to load loaddef
   #+name: loaddef
   #+begin_src emacs-lisp
     (require 'org-loaddefs () t)
   #+end_src

** Les fichiers de l'agenda
   #+begin_src emacs-lisp
     (require 'em-glob)
     (defconst org-agenda-files-cours
       (list* "~/org/cours.org" "~/org/edt.org" "~/org/agenda-pronote.org"
              (cl-loop for dir in (eshell-extended-glob "~/travail/cours/*/")
                       for name = (file-name-nondirectory (directory-file-name dir))
                       for org = (expand-file-name (concat name ".org") dir)
                       when (file-readable-p org) collect org)))
     (defconst org-agenda-incoming-cours "~/org/cours.org")

     (defconst org-agenda-files-floss '("~/org/prgm.org"))
     (defconst org-agenda-incoming-floss "~/org/prgm.org")

     (defconst org-agenda-files-personel (list "~/org/personel.org"
                                     "~/org/aniversaire.org"
                                     "~/org/contacts.org"))
     (defconst org-agenda-incoming-personel "~/org/personel.org")

     (defconst org-agenda-files-main '("~/org/notes.org"))
     (defconst org-agenda-incoming-main "~/org/notes.org")

     (setq org-agenda-files
           (append org-agenda-files-floss
                   org-agenda-files-personel
                   org-agenda-files-main
                   org-agenda-files-cours
                   '("~/org/sante.org")))
   #+end_src

** Le repertoire de l'agenda
#+name: agenda-directory
#+begin_src emacs-lisp
  (defun myorg-cd-to-org (&rest args)
    (cd "~/org/"))

  (advice-add 'org-agenda-list :after 'myorg-cd-to-org)
#+end_src

** Affichage
#+name: startup
#+begin_src emacs-lisp
  (setq org-startup-with-inline-images t)
  (setq org-startup-indented t)
  (setq org-startup-truncated ())
#+end_src

** Auto fill
#+name: auto-fill
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'auto-fill-mode-off)
#+end_src

** Yasnippet
#+name: yasnipett-org
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'yas-minor-mode)
#+end_src

** Exportons vers ical
   #+begin_src emacs-lisp
     (setq org-combined-agenda-icalendar-file "~/org/org.ics")

     ;;; Plus utilisé...
     (defun org-export-icalendar-cours ()
       (interactive)
       (let ((org-icalendar-combined-agenda-file "~/org/cours.ics")
             (org-agenda-files org-agenda-files-cours))
         (org-icalendar-combine-agenda-files)))

     (setq org-icalendar-date-time-format ":%Y%m%dT%H%M%S")
     (setq org-icalendar-store-UID t)
     (setq org-icalendar-timezone "Europe/Paris")
     (setq org-icalendar-include-todo ())
     (setq org-icalendar-with-timestamps 'active)
     (setq org-icalendar-use-deadline '(event-if-not-todo event-if-todo))
     (setq org-icalendar-use-scheduled '(event-if-not-todo event-if-todo))
   #+end_src

** for caldav
#+name: caldav-advice
#+begin_src emacs-lisp
  (defun my-caldav-advice (oldfun)
    (let ((org-babel-confirm-evaluate-answer-no t))
      (apply oldfun ())))

  (advice-add 'org-caldav-sync :around #'my-caldav-advice)

  (autoload 'org-caldav-sync "org-caldav" nil t)
#+end_src

** Utilisons des dates européennes
#+begin_src emacs-lisp
  (setq calendar-date-style 'european)
#+end_src
** Lisons les jours et mois français
   #+name: french-date
   #+begin_src emacs-lisp
     (defvar parse-time-weekdays-french
       '(("dim" . 0) ("lun" . 1) ("mar" . 2) ; colision with march
         ("mer" . 3) ("jeu" . 4) ("ven" . 5)
         ("sam" . 6)
         ("dimanche" . 0) ("lundi" . 1)
         ("mardi" . 2) ("mercredi" . 3)
         ("jeudi" . 4) ("vendredi" . 5)
         ("samedi" . 6)))

     ;; No jan, mar, sep oct nov and dec because they are the same in English
     ;; No jui because jui can be juin or juillet, use jun or jul (English)

     (defvar parse-time-months-french
       '(("fev" . 2) ("avr" . 4) ("mai" . 5)
         ("aou" . 8)
         ("janvier" . 1) ("fevrier" . 2)
         ("mars" . 3) ("avril" . 4) ("juin" . 6)
         ("juillet" . 7) ("aout" . 8)
         ("septembre" . 9) ("octobre" . 10)
         ("novembre" . 11) ("decembre" . 12)))


     (with-eval-after-load 'parse-time
       (setq parse-time-weekdays (nconc parse-time-weekdays
                                        parse-time-weekdays-french))
       (setq parse-time-months
             (nconc  (--filter (not (string= "mar" (car it))) parse-time-months) ; mar is for mardi, not march
                     parse-time-months-french)))
   #+end_src

** Link to imap gnus
#+name: link-to-all-mail
#+begin_src emacs-lisp
  (defun my-org-link-to-gmail-all-messages ()
    (interactive)
    (when (org-in-regexp org-bracket-link-regexp 1)
      (let ((link-pos (cons (match-beginning 1) (match-end 1)))
            (link (org-link-unescape (org-match-string-no-properties 1))))
        (when (string-match "^gnus:\\(.*\\)#\\(.*\\)$" link)
          (save-excursion
            (goto-char (car link-pos))
            (delete-region (car link-pos) (cdr link-pos))
            (insert (org-link-escape (concat "gnus:nnimap+gmail:[Gmail]/Tous les messages#" (match-string 2 link)))))))))
#+end_src

** Voyage dans le temps dans l'agenda
    :PROPERTIES:
    :ID:       21c708ba-8ed1-41df-bff9-e24264136ae1
    :END:
#+begin_src emacs-lisp
  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "M-<right>") 'org-agenda-later)
    (define-key org-agenda-mode-map (kbd "M-<left>") 'org-agenda-earlier))
#+end_src

** Pour latex
    :PROPERTIES:
    :ID:       56511aef-f5ce-446e-9ca2-d2089bba2938
    :END:
#+begin_src emacs-lisp
  (setq org-export-latex-inputenc-alist '(("utf8" . "utf8x")))
  (setq org-latex-inputenc-alist '(("utf8" . "utf8x")))
#+end_src
*** Des théoremes latex et html
    :PROPERTIES:
    :ID:       15ebdea3-f289-46ed-a8a3-8ca1b1c1091b
    :END:
#+begin_src emacs-lisp
  (with-eval-after-load 'org-exp-blocks
    (defun org-export-blocks-format-theorem (body &rest headers)
      "Format theorem BODY as a theorem and return it formatted for export.
  Currently, this only does something for HTML export, for all
  other backends, it converts the comment into an EXAMPLE segment."
      (let ((theorem-style (if headers (car headers) "theorem"))
            (title (if (cdr headers) (mapconcat 'identity (cdr headers) " "))))
        (cond
         (htmlp ;; We are exporting to HTML
          (concat "#+BEGIN_HTML\n"
                  "<div class=\"org-"
                  theorem-style
                  "\">\n"
                  "<b>" (upcase-initials theorem-style) "</b>"
                  (if (and title (> (length title) 0)) (concat ": " title "</br>\n") "</br>\n")
                  "<p>\n"
                  "#+END_HTML\n"
                  body
                  (if (string-match "\n$" body) "" "\n")
                  "#+BEGIN_HTML\n"
                  "</p>\n"
                  "</div>\n"
                  "#+END_HTML\n"))
         (latexp ;;we are exporting to latex
          (concat "#+BEGIN_LATEX\n"
                  "\\begin{" theorem-style "}"
                  (if (and title (> (length title) 0)) (concat "[" title "]\n") "\n")
                  "#+END_LATEX\n"
                  body

                  (if (string-match "\n$" body) "" "\n")
                  "#+BEGIN_LATEX\n"
                  "\\end{" theorem-style "}\n"
                  "#+END_LATEX\n"))
         (t ;; This is not HTML nor latex, so just export the body
          (concat "\n"
                  (upcase-initials theorem-style)
                  (if title (concat ": " title "\n\n") "\n\n")
                  body
                  (if (string-match "\n\\'" body) "\n\n" "\n"))))))

    (org-export-blocks-add-block '(theorem org-export-blocks-format-theorem t)))
#+end_src

*** Une classe
    #+name: org-latex-class
    #+begin_src emacs-lisp
      (with-eval-after-load 'ox-latex
        (add-to-list 'org-latex-classes
                     '("ledger"
                       "\\documentclass[a4paper]{article}
                         \\usepackage{myhead}
                         \\usepackage{hyperref}
                         \\header{Les comptes}
                         [NO-DEFAULT-PACKAGES]
                         [PACKAGES]
                         [EXTRA]"
                       ("\\section{%s}" . "\\section*{%s}")
                       ("\\subsection{%s}" . "\\subsection*{%s}")
                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                       ("\\paragraph{%s}" . "\\paragraph*{%s}")
                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
        (add-to-list 'org-latex-classes
                     '("simple"
                       "\\documentclass[a4paper]{article}
              \\usepackage{myhead}
              \\usepackage{hyperref}
              \\renewcommand{\\maketitle}{}
              [NO-DEFAULT-PACKAGES]
              [PACKAGES]
              [EXTRA]"
                       ("\\section{%s}" . "\\section*{%s}")
                       ("\\subsection{%s}" . "\\subsection*{%s}")
                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                       ("\\paragraph{%s}" . "\\paragraph*{%s}")
                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
    #+end_src

** Pour l'agenda: la fête des mères et quelques autres fêtes.
    :PROPERTIES:
    :ID:       a1777554-e0a1-4a33-8e55-3e8e9620580e
    :END:
#+begin_src emacs-lisp
  (defun holiday-fete-des-mere ()
    (if (let ((displayed-month 05))
          (equal (holiday-easter-etc 49 "") (holiday-float 5 0 -1 "")))
        (holiday-float 6 0 1 "fête des mères")
        (holiday-float 5 0 -1 "fête des mères")))

  (setq holiday-bahai-holidays ())

  (defun jd:org-current-time ()
   "Return current-time if date is today."
   (when (equal date (calendar-current-date))
     (format-time-string "%H:%M Current time" (current-time))))
#+end_src
** Exporting org-diary-class
    :PROPERTIES:
    :ID:       e82ed7a3-5fd7-4c62-9cef-041b114d2f14
    :END:
#+begin_src emacs-lisp
  (require 'ical-for-org)
#+end_src
** org babel
:PROPERTIES:
:ID:       2c687ffb-3e38-4586-82de-903e0a9e9cf4
:END:
*** The languages
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (ditaa . t)
     (dot . t)
     (emacs-lisp . t)
     (gnuplot . t)
     (haskell . nil)
     (latex . t)
     (ledger . t)
     (ocaml . nil)
     (octave . t)
     (python . t)
     (ruby . t)
     (screen . nil)
     (sh . t)
     (sql . nil)
     (sqlite . t)))
#+end_src
*** An advice to automatically display images
#+begin_src emacs-lisp
  (advice-add 'org-babel-execute-maybe :after #'org-display-inline-images)
#+end_src
*** library of babel
#+name: lob
#+begin_src emacs-lisp
  (let ((my-lob "/home/moi/travail/cours/my-lob.org"))
    (when (file-exists-p my-lob)
      (org-babel-lob-ingest my-lob)))
#+end_src

** mouvement dans org
    :PROPERTIES:
    :ID:       0a0e33df-e9f4-43c1-aee5-c9de88fe665c
    :END:
#+begin_src emacs-lisp
  (defun org-beginning-of-line-home-end (oldfun &rest arg)
    (let* ((keys (recent-keys))
           (len (length keys))
           (key1 (if (> len 0) (elt keys (- len 1)) nil))
           (key2 (if (> len 1) (elt keys (- len 2)) nil))
           (key3 (if (> len 2) (elt keys (- len 3)) nil))
           (key-equal-1 (equal key1 key2))
           (key-equal-2 (and key-equal-1 (equal key2 key3))))
      (cond (key-equal-2 (goto-char (point-min)))
            (key-equal-1 (push-mark home-end-marker)
                         (move-to-window-line 0))
            (t (setq home-end-marker (copy-marker (point)))
               (apply oldfun arg)))))

  (advice-add 'org-beginning-of-line :around #'org-beginning-of-line-home-end)

  (defun org-end-of-line-home-end (oldfun &rest arg)
    (let* ((keys (recent-keys))
           (len (length keys))
           (key1 (if (> len 0) (elt keys (- len 1)) nil))
           (key2 (if (> len 1) (elt keys (- len 2)) nil))
           (key3 (if (> len 2) (elt keys (- len 3)) nil))
           (key-equal-1 (equal key1 key2))
           (key-equal-2 (and key-equal-1 (equal key2 key3))))
      (cond (key-equal-2 (goto-char (point-max)))
            (key-equal-1 (push-mark home-end-marker)
                         (move-to-window-line -1)
                         (apply oldfun arg))
            (t (setq home-end-marker (copy-marker (point)))
               (apply oldfun arg)))))

  (advice-add 'org-end-of-line :around #'org-end-of-line-home-end)
#+end_src
** Rentrer des notes
    :PROPERTIES:
    :ID:       d61e5a2f-3778-4ac2-8830-c987fa4d3c69
    :END:
#+begin_src emacs-lisp
  ;; (defun note-for-org ()
  ;;   (interactive)
  ;;   (org-narrow-to-subtree)
  ;;   (let ((col (org-table-current-column)))
  ;;     (goto-char (org-table-begin))
  ;;     (org-table-recalculate)
  ;;     (while (isearch-forward)
  ;;       (let* ((line (org-table-current-line))
  ;;              (old (org-table-get line col))
  ;;              (new (read-string "Note:" old)))
  ;;         (org-table-put line col new))
  ;;       (goto-char (org-table-begin))
  ;;       (org-table-recalculate))
  ;;     (widen)))

  (defvar my-org-table-column)

  (make-variable-buffer-local 'my-org-table-column)

  (defvar note-for-org-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "n") 'helm-find-student-in-table)
      (define-key map (kbd "RET") 'helm-find-student-in-table)
      (define-key map (kbd "q") 'helm-note-quit)
      (define-key map (kbd "a") 'my-helm-insert-na)
      map))

  (define-minor-mode note-for-org-mode
    "minor mode for editing note in org"
    :init-value ()
    :lighter "note"
    :keymap 'note-for-org-mode-map
    (if note-for-org-mode
        (org-narrow-to-subtree)
      (widen))
    (setq my-org-table-column (org-table-current-column)))

  (defun my-helm-insert-na ()
    (interactive)
    (insert "NA"))

  (defun helm-note-quit ()
    (interactive)
    (note-for-org-mode -1)
    (widen))

  (defun helm-find-student-in-table ()
    (interactive)
    (org-table-maybe-eval-formula)
    (org-table-maybe-recalculate-line)
    (org-table-justify-field-maybe)
    (helm-occur)
    (when (boundp 'my-org-table-column)
      (org-table-goto-column my-org-table-column))
    (setq this-command 'org-cycle))

  (defun helm-find-student-in-tree ()
    (interactive)
    (outline-up-heading 1)
    (org-narrow-to-subtree)
    (helm-occur)
    (widen))
#+end_src
** Recopier les note pour le trimestre
#+name: note-tri
#+begin_src emacs-lisp
  (defun copy-note-here ()
    (interactive)
    (unless (boundp 'note-for-org-trimestre)
      (set (make-local-variable 'note-for-org-trimestre) (read-from-minibuffer "trimestre: ")))
    (unless (boundp 'note-for-org-table-name)
      (set (make-local-variable 'note-for-org-table-name) (read-from-minibuffer "Nom de la table: " (format "note-%s" note-for-org-trimestre))))
    (let* ((start (point-marker)))
      (outline-previous-visible-heading 1)
      (looking-at "\*+ \\(.*\\)")
      (let* ((name  (match-string-no-properties 1))
             (regex-name (setq name (replace-regexp-in-string " " "[| ]+" name)))
             beg end
             names maxs notes)
        (goto-char (point-min))
        (search-forward note-for-org-table-name)
        (forward-line 1)
        (setq beg (point))
        (forward-line 1)
        (setq end (point))
        (setq names (split-string (buffer-substring-no-properties beg end) " *| *"))
        (setq beg (point))
        (forward-line 1)
        (setq end (point))
        (setq maxs (split-string (buffer-substring-no-properties beg end) " *| *"))

        (search-forward-regexp regex-name)
        (forward-line 0)
        (setq beg (point))
        (forward-line 1)
        (setq end (point))
        (setq notes (split-string (buffer-substring-no-properties beg end) " *| *"))
        (goto-char start)
        (insert "- " note-for-org-trimestre " :: ")
        (cl-loop for max in maxs
                 for name in names
                 for note in notes
                 if (not (member max '("\n" "")))
                 do (insert " " name ": " note "/" max)))))
#+end_src
** Pour les livrets
#+name: livret
#+begin_src emacs-lisp
  (defun trimestre-to-org ()
    (cond
     ((looking-at "\tTrim\\(.\\)\t\"\\(..?\\)./\\(..\\)\"\t\\(..?,..\\)\t\"\\([^\"]+\\)\"\n")
      (prog1
          (match-substitute-replacement "trimestre \\1 *\\4/20* \\5")
        (goto-char (match-end 0))))
     ((looking-at "\tTrim\\(.\\)\t*\n")
      (prog1
          (match-substitute-replacement "trimestre \\1 non inscrit")
        (goto-char (match-end 0))))
     ((looking-at "\tTrim\\(.\\)\t\t\\([^\t]*\\)\t\"?\\([^\"]+\\)\"?\n")
      (prog1
          (match-substitute-replacement "trimestre \\1 \\2, \\3")
        (goto-char (match-end 0))))))

  (defun livret-to-org ()
    (interactive)
    (let (nom trim1 trim2 trim3 année pos)
      (while (setq trim1 (trimestre-to-org))
        (setq trim2 (trimestre-to-org))
        (setq trim3 (trimestre-to-org))

        (search-forward-regexp "\"\\([^\"]+\\)\"\tAnnée\t\\(?:\"\\(.?.?\\).?/\\(.?.?\\)\"\\)?\t\\([^\t]+\\)\t?\n")
        (setq nom (match-substitute-replacement "\\1"))
        (setq année (match-substitute-replacement "Année: *\\4/20*"))
        (setq pos (point))
        (goto-char (point-max))
        (insert "- " nom "\n")
        (insert "  - " trim1 "\n")
        (when trim2
          (insert "  - " trim2 "\n"))
        (when trim3
          (insert "  - " trim3 "\n"))
        (when année
          (insert "  - " année "\n"))
        (goto-char pos))))
#+end_src

** Calculer des moyennes...
   #+name: moyenne-in-org
   #+begin_src emacs-lisp
     (defun mean-compute (coefs tots values)
       "compute mean with stuff"
       (let ((tot-coef (cl-loop
                        for coef in coefs
                        for tot in tots
                        for v in values
                        when (and v (numberp v))
                        sum (* coef tot)
                        ))
             (tot-note (cl-loop
                       for coef in coefs
                       for tot in tots
                       for v in values
                       when (and v (numberp v))
                       sum (* coef v)
                       )))
         (if (= tot-coef 0)
             10
             (/ (float (ceiling (/ (* 200. (float tot-note)) tot-coef))) 10))))

     (defmacro defmycal-on-list (op)
       (let ((fun (intern (format "my-%s" op))))
         `(defun ,fun (&rest vecs)
            (require 'calc-vec)
            (let ((vecs (if (listp (car vecs))
                           (car vecs)
                         vecs)))
              (calc-eval ,(format "v%s($)" op) ()
                         (apply #'calcFunc-vec
                                (mapcar #'(lambda (x)
                                            (condition-case nil
                                                (math-read-number (number-to-string x))
                                              (error nil)))
                                        (remove-if-not #'numberp vecs))))))))

     (defconst NA 'NA)

     (defmycal-on-list min)
     (defmycal-on-list max)
     (defmycal-on-list mean)
     (defmycal-on-list sdev)
   #+end_src
** org-mobile
    :PROPERTIES:
    :ID:       b9a1d2b5-5823-4f6e-a8b5-33ebfb942917
    :END:
#+begin_src emacs-lisp
  (setq org-mobile-directory "~/org-mobile")
  (add-hook 'org-mobile-pre-pull-hook
            (lambda ()
              (shell-command "cd ~/org-mobile; make pull")))
  (add-hook 'org-mobile-post-push-hook
            (lambda ()
              (shell-command "cd ~/org-mobile; make push")))

  (defun rv-org-mobile-push ()
    (interactive)
    (let (org-agenda-start-on-weekday
          (string-to-number (format-time-string "%w")))
      (org-mobile-push)))

  (setq org-agenda-custom-commands
        '(("n" "Next 21 days" agenda "" ((org-agenda-span 21)))
          ("w" "Full week" agenda "" ((org-agenda-span 9)
                                      (org-agenda-start-on-weekday 6)))))

#+end_src

** ditaa
   #+begin_src emacs-lisp
     (setq org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar")
   #+end_src
** ox
   #+name: org-export
   #+begin_src emacs-lisp :tangle no
     (setq org-latex-classes '(("beamer" "\\documentclass{beamer}" ("\\section{%s}" . "\\section*{%s}"))
                               ("article" "\\documentclass[11pt]{article}"
                                ("\\section{%s}" . "\\section*{%s}")
                                ("\\subsection{%s}" . "\\subsection*{%s}")
                                ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                                ("\\paragraph{%s}" . "\\paragraph*{%s}")
                                ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
                               ("report" "\\documentclass[11pt]{report}"
                                ("\\part{%s}" . "\\part*{%s}")
                                ("\\chapter{%s}" . "\\chapter*{%s}")
                                ("\\section{%s}" . "\\section*{%s}")
                                ("\\subsection{%s}" . "\\subsection*{%s}")
                                ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
                               ("book" "\\documentclass[11pt]{book}" ("\\part{%s}" . "\\part*{%s}")
                                ("\\chapter{%s}" . "\\chapter*{%s}")
                                ("\\section{%s}" . "\\section*{%s}")
                                ("\\subsection{%s}" . "\\subsection*{%s}")
                                ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
   #+end_src

** ediff of org mode
   #+name: ediff-org-mode
   #+begin_src emacs-lisp
     ;; diff hooks for org mode
     (add-hook 'ediff-select-hook 'f-ediff-org-unfold-tree-element)
     (add-hook 'ediff-unselect-hook 'f-ediff-org-fold-tree)
     ;; Check for org mode and existence of buffer
     (defun f-ediff-org-showhide(buf command &rest cmdargs)
       "If buffer exists and is orgmode then execute command"
       (if buf
           (if (eq (buffer-local-value 'major-mode (get-buffer buf)) 'org-mode)
               (save-excursion (set-buffer buf) (apply command cmdargs)))))

     (defun f-ediff-org-unfold-tree-element ()
       "Unfold tree at diff location"
       (f-ediff-org-showhide ediff-buffer-A 'org-reveal)
       (f-ediff-org-showhide ediff-buffer-B 'org-reveal)
       (f-ediff-org-showhide ediff-buffer-C 'org-reveal))

     (defun f-ediff-org-fold-tree ()
       "Fold tree back to top level"
       (f-ediff-org-showhide ediff-buffer-A 'hide-sublevels 1)
       (f-ediff-org-showhide ediff-buffer-B 'hide-sublevels 1)
       (f-ediff-org-showhide ediff-buffer-C 'hide-sublevels 1))
   #+end_src

** For R
#+name: org-for-r
#+begin_src emacs-lisp
  (defun my-init-r-ess ()
    (comint-send-string (get-buffer-process (current-buffer)) "source('/usr/share/ess/etc/ESSR/R/.basic.R')\n"))

  (add-hook 'ess-post-run-hook #'my-init-r-ess)
#+end_src

** For yasnipet
#+name: org-for-yas
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "<C-tab>") #'yas-expand))
#+end_src

** For odt
#+name: for-odt
#+begin_src emacs-lisp
  (setq org-latex-to-mathml-convert-command "~/bin/math-to-web %o %I")
  (setq org-latex-to-mathml-jar-file "\"\"")
#+end_src


* from custom
  :PROPERTIES:
  :ID:       75dfd292-47cb-4284-82d9-fdb440701600
  :END:
#+begin_src emacs-lisp
  (setq org-agenda-include-diary t)
  (setq org-capture-templates
        (quote (("n" "note" entry (file+headline "~/org/notes.org" "Notes")
                     "* [Something] \n   %a" :kill-buffer t)
                ("m" "mailnote" entry (file+headline "~/org/notes.org" "Notes")
                     "** De : %:from Objets : %:subject\n   %a" :kill-buffer t)
                ("r" "rendezvous" entry (file+headline "/home/moi/org/personel.org" "Rendez Vous")
                     "* \n%T" :kill-buffer t)
                ("k" "kill-ring" entry (file+headline "~/org/notes.org" "Notes")
                     "* \n%c" :kill-buffer t)
                ("c" "Contacts" entry (file+headline "~/org/contacts.org" "Divers")
                     "** %(org-contacts-template-name) \n   :PROPERTIES:\n   :EMAIL: %(org-contacts-template-email)\n   :END:\n")
                ("i" "messageid" entry (file+headline "~/org/notes.org" "Notes")
                     "* %:subject\n  :PROPERTIES:\n  :SUBMITER: %:from\n  :END:\n  <%:message-id>\n  %:body"
                     :kill-buffer t))))
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-enforce-todo-dependencies t)
  (setq org-export-with-toc nil)
  (setq org-hide-leading-stars t)
  (setq org-modules '(org-bbdb org-bibtex org-gnus org-id org-info org-jsinfo org-irc org-wl org-w3m))
  (setq org-refile-targets (quote ((org-agenda-files :maxlevel . 3))))
  (setq org-return-follows-link t)
  (setq org-time-stamp-custom-formats '("<%a %d/%m/%y>" . "<%a %d/%m/%y %H:%M>"))
  (setq org-todo-keywords '((sequence "TODO" "NEXT(n)" "WAIT(w!)" "PROGRESS(p)" "|" "ABANDON(a!)" "DONE(d!)")))
#+end_src
