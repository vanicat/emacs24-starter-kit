* Finding the mode
  #+name: ledger-is-there
  #+begin_src emacs-lisp
    (add-to-list 'load-path "/home/moi/prog/ledger/ledger/lisp/")

    (autoload 'ledger-mode "ledger-mode")
  #+end_src

* Auto mode
  :PROPERTIES:
  :ID:       c93b0251-76a5-4da9-8bd4-adf27e84f200
  :END:
  #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
  #+end_src

* Face
  #+name: ledger-face
  #+begin_src emacs-lisp
    (eval-after-load 'ldg-fonts
      '(progn
        (set-face-attribute 'ledger-font-xact-highlight-face nil
         :background "gray20")
        (set-face-attribute 'ledger-occur-xact-face nil
         :background "gray10")))
  #+end_src


* Align
  #+name: ledger-align
  #+begin_src emacs-lisp
    (setq ledger-post-amount-alignment-column 70)
  #+end_src

* Sorting
  #+name: sort-ledger
  #+begin_src emacs-lisp
    (eval-after-load 'ledger
      '(defun ledger-sort ()
        (interactive)
        (save-excursion
          (goto-char (point-min))
          (sort-subr
           nil
           (lambda ()
             (if (re-search-forward
                  (concat "^[0-9/.=-]+\\(\\s-+\\*\\)?\\(\\s-+(.*?)\\)?\\s-+"
                          "\\(.+?\\)\\(\t\\|\n\\| [ \t]\\)") nil t)
                 (goto-char (match-beginning 0))
                 (goto-char (point-max))))
           (lambda () (forward-paragraph))
           (lambda ()
             (looking-at "^\\([0-9/]+\\)[ \\*]+\\(.*\\)$")
             (concat (match-string 1) (match-string 2)))))))
  #+end_src

* Auto insert
  #+name: auto-transaction
  #+begin_src emacs-lisp
    (defvar ledger-liability ()
      "A list of list containing automatic transaction to insert

    each list look like
     (PAYEE ACCOUNTS)
    where ACCOUNTS is a list of list that look like
     (ACCOUNT-NAME AMMOUNT)
    AMOUNT are supposed to be in euro, and are optional")

    (defun ledger-insert-a-transaction (date num payee &rest accounts)
      (insert date)
      (when num
        (insert " (")
        (insert num)
        (insert ")"))
      (when payee
        (insert " ")
        (insert payee))
      (insert "\n")
      (dolist (account accounts)
        (insert "    ")
        (insert (car account))
        (when (cadr account)
          (insert "                            € ")
          (insert (cadr account))
          (when (caddr account)
            (insert "  ; ")
            (insert (caddr account))))
        (insert "\n"))
      (insert "\n"))


    (defun ledger-insert-monthly-liability (&optional date)
      (interactive (list (when current-prefix-arg
                           (read-from-minibuffer "Date of automatic transaction: "))))
      (unless date
        (setq date (format-time-string "%Y/%m/%d")))
      (dolist (trans ledger-liability)
        (apply #'ledger-insert-a-transaction date () (car trans)
               (cdr trans))))

      #+end_src

* Auto conversion QIF
  :PROPERTIES:
  :ID:       23aef8bf-b49a-432c-9e81-6dcbfa0d5fd0
  :END:
** TODO balance account différent suivants le signe de la transaction
   :PROPERTIES:
   :ID:       54a0075c-66bb-40d3-8d67-f21ca7785558
   :END:

  #+begin_src emacs-lisp
    (defvar ledger-read-from-qif-accounts
      '("Actifs:Banque:BPMC:Courant"
        "Actifs:Banque:BPACA:Courant"
        "Actifs:Banque:BPMC:Solidarité"
        "Passifs:Carte de crédit"))

    (defvar ledger-read-from-qif-default-balance-account
      "Dépenses:Divers")

    (defvar ledger-read-from-qif-auto-assoc
      '(("RET DAB.*" . "Dépenses:Divers")
        ("CHEQUE" . "Dépenses:Divers")))

    (defun ledger-read-from-qif (qif-file &optional account)
      (interactive "fread from: \np")
      (unless (stringp account)
        (setq account
              (completing-read "account: " ledger-read-from-qif-accounts () 'confirm)))
      (pop-to-buffer "ledger-import")
      (delete-region (point-min) (point-max))
      (insert-file qif-file)
      (goto-char (point-min))
      (replace-string "" "")
      (goto-char (point-min))
      (unless (looking-at "!Type:.*\n")
        (error "not a qif bank file."))
      (delete-region (match-beginning 0) (match-end 0))
      (insert "; -*-ledger-*-\n")
      (while (not (eobp))
        (cond
          ((looking-at "^D\\([0-9]\\{2\\}\\)/\\([0-9]\\{2\\}\\)/\\([0-9]\\{4\\}\\)\n")
           (replace-match "\\3/\\2/\\1"))
          ((looking-at "^D\\([0-9]\\{2\\}\\)/\\([0-9]\\{2\\}\\)/\\([0-9]\\{2\\}\\)\n")
           (replace-match "20\\3/\\2/\\1"))
          (t
           (error "strange file")))
        (let (balance-account
              (li ledger-read-from-qif-auto-assoc)
              note amount num payee)
          (while (not (looking-at "\\^\n"))
            (cond
              ((looking-at "T\\(-?[0-9]*\\(\\.[0-9]*\\)?\\)\n")
               (setq amount (match-string 1)))
              ((looking-at "N\\([^\n]*\\)\n")
               (setq num (match-string 1)))
              ((looking-at "P\\([^\n]*\\)\n")
               (setq payee (match-string 1)))
              ((looking-at "M\\([^\n]*\\)\n")
               (setq note (match-string 1)))
              (t
               (error "strange file")))
            (delete-region (match-beginning 0) (match-end 0)))
          (delete-region (match-beginning 0) (match-end 0))
          (when num
            (insert " (")
            (insert num)
            (insert ")"))
          (when payee
            (insert " ")
            (insert payee))
          (insert "\n")
          (insert "    ")
          (insert account)
          (insert "                            € ")
          (insert amount)
          (when (and note (not (string= note "")))
            (insert "  ; ")
            (insert note))
          (insert "\n")
          (while (and li (not (or (string-match (caar li) payee)
                                  (and note
                                       (string-match (caar li) note)))))
            (setq li (cdr li)))
          (if li
              (setq balance-account (cdar li))
              (setq balance-account ledger-read-from-qif-default-balance-account))
          (insert "    ")
          (insert balance-account)
          (insert "\n")
          (insert "\n")))
      (ledger-mode))
  #+end_src

* Auto conversion OFX
** To sexp
   #+name: from-ofx-to-sexp
   #+begin_src emacs-lisp
     (defun from-ofx-to-sexp (file)
       (with-temp-buffer
         (insert-file file)
         (goto-char (point-min))
         (search-forward "<OFX>")
         (delete-region (point-min) (point))
         (insert "(ofx ")
         (while (search-forward-regexp (rx (not (any space ?\) ?\n))) () t)
           (goto-char (match-beginning 0))
           (cond ((looking-at (rx "</" (group-n 1 (* (not (any ?>)))) ">"))
                  (delete-region (match-beginning 0) (match-end 0))
                  (insert ")"))
                 ((looking-at (rx (group-n 2 "<" (group-n 1 (* (not (any ?>)))) ">")
                                  (*? anything)
                                  (group-n 3 "</" (backref 1) ">")))
                  (let ((tag (match-string 1)))
                    (delete-region (match-beginning 3) (match-end 3))
                    (goto-char (match-beginning 3))
                    (insert ")")
                    (goto-char (match-beginning 0))
                    (delete-region (match-beginning 2) (match-end 2))
                    (insert "(")
                    (insert (downcase tag))
                    (insert " ")))
                 ((looking-at (rx "<" (group-n 1 (zero-or-more (not (any ?>)))) ">"))
                  (let ((tag (match-string 1)) pt)
                    (delete-region (match-beginning 0) (match-end 0))
                    (insert "(")
                    (insert (downcase tag))
                    (insert " ")
                    (setq pt (point))
                    (search-forward-regexp (rx eol))
                    (insert ")")
                    (goto-char pt)))
                 ((looking-at (rx (* not-newline) ?\) eol))
                  (insert "\"")
                  (goto-char (match-end 0))
                  (insert "\"")
                  (forward-char 1))
                 ((looking-at (rx (* not-newline) eol))
                  (insert "\"")
                  (goto-char (1+ (match-end 0)))
                  (insert "\""))))
         (insert ")")
         (goto-char (point-min))
         (read (current-buffer))))
   #+end_src
** insert the sexp
   #+name: from-ofx-to-sexp
   #+begin_src emacs-lisp
     (defun insert-my-ledegr (file)
     )
   #+end_src
